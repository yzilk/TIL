:多態性
親クラス型の配列を作ると親クラスのオブジェクトを入れることができるだけでなく
子クラスオブジェクトをいれることができる


＊シグネチャ＝メソッド名・引数の型・個数・順番の組み合わせ
（メソッド名以外はオーバーロードできる環境と被る）
オーバライド（上書き乗っ取り）
サブクラスから上書きできる機能

配列length フィールド　　：参照型だけどクラスじゃないからメソッド持てない
文字列 length()メソッド　：クラスだから
arrayLisst size()メソッド

＊とりあえず子クラス（スマホ）をNEWすると継承元である
親のスーパーの（電話）のコンストラクタ（なければデフォルトコンストラクタ（最初のところ））
を参照してからメインに戻ってくる

＊変数隠し
親と子で同じ名前のフィールドを定義すると
親クラスにアクセスできなくなるので注意

＊注意
引数があるコンストラクタを作るとデフォルトコンストラクタが
消えるのでエラーになりやすい（とりあえずデフォルトコンストラクタ引数なしを書いておけばいいんじゃね）


＊ファイナル使用方法①
ファイナルを付けると継承できなくなります
メソッドに着けるとオーバーライドを禁止できる、ストリングクラスは継承できない！！


*ファイナル使用方法②
変数に着けると定数となる
何にも変更しないで使ってください！という意味
MATHクラスとかで使ってる
STATIC FINALでオブジェクト作らないでファイナル、すなわち定数で使うことができるものとか、、、
[ex.]
public class Test {
	public static final int MAX_VALUE = 100;
	public static final String FIXED_NAME = "ちだ";
}


*println とかではobjectクラスかintegerクラスとか使って
なんとかtoString()メソッドで文字列出してくれてたわけ

*equals()メソッド
これ使うとif(参照型名前＝＝参照型名前)
の時にハッシュコードの比較になってしまうところを
if(参照型名前.equals(参照型名前))
を使うことで中身を参照できるゼ

*抽象クラス【ABSTRACT】はオブジェクトが作れない
ex. abstract void bark();  →カッコの後のカッコがない！！！
→継承して継承した子クラスで完成させてからオブジェクトを使えるヨ
イメージはルール設定みたいなもん

*強制的にフィールドの場合はpublic static final
メソッドの場合はpublic abstract （+void）がつくvoid だけ書いても無駄

*一応インターフェースをextendsしてサブインターフェースが作れるヨ
でも結局どっちもオブジェクトは作れないヨ

*インタフェース　
抽象メソッド void 名前(); →これはパブリックになってます
メソッドが描けます
static だけとか
デフォルトメソッドだけ
でもメソッドは書けます（ただしNEWはできません）

NEWするためにインタフェースを継承（じゃないんだけど）
をするときは「実装する」となる　implementsです
継承は1個だけだけどインプリメンツは2個とかできる
インヘリタンス（継承）しつつ、インプリメンツもおｋ

*instance ofで判定ができる
戻り値はbooleanである

*多態性＝＝ポリモーフィズム
